import "Util.m" : __GetForms, __GetSlice;
import "GlobalVars.m" : __SANITY_CHECK;
import "Invariants.m" : __FusionBlock, __Coordinate_Spread, __ReduceByFuse;

__scan_SVD := function(sings)
  // Scan last to first looking at the slopes of the normalized 
  // SVD plot adjacent points.  The first inflection point (slope below -1)
  // is where we stop.
  slope := 0;
  start := #sings;
//   while (start gt 1) 
//     and ((sings[start] eq 0) or (sings[start-1]/sings[start] lt 5 )) do
//     start := start - 1;
//   end while;
  while (start gt 1) and (slope gt -1 ) do
     slope := (sings[start-1]-sings[start])/(#sings*sings[1]);
     start := start - 1;
  end while;
  return start;
end function;

__A_Centroid_mat := function(seq, dims, A : repeats := {})
  // Initial setup.
  a := Minimum(A);
  B := A diff {a};
  d := &*(dims);
  K := Parent(seq[1]);
  v := #dims;
  d_a := dims[v-a];
  M := ZeroMatrix(K, #B*d, &+[dims[v-x]^2 : x in A]);
  I := IdentityMatrix(K, d_a);
  r_anchor := Ncols(M) - d_a^2 + 1;
  
  vprintf TensorSpace, 1 : "Constructing a %o by %o matrix over %o.\n", 
    Ncols(M), Nrows(M), K;
  
  // Construct the appropriate matrix. 
  // We place the a block on the right-most side of M.
  row := 1;
  col := 1;
  while #B gt 0 do
    b := Maximum(B);
    B := B diff {b};
    d_b := dims[v-b];

    Mats := __GetForms(seq, dims, b, a : op := true);
    LeftBlocks := [Matrix(K, [Eltseq(Mats[k][i]) : k in [1..#Mats]]) : 
      i in [1..d_a]];
    Mats := [Transpose(X) : X in Mats];
    RightBlock := -Matrix(K, &cat[[Eltseq(Mats[k][j]) : k in [1..#Mats]] : 
      j in [1..d_b]]);
    delete Mats;

    // Building the matrix strip for the equation x_a = x_b.
    // The blocks corresponding to the x_a part.
    InsertBlock(~M, KroneckerProduct(I, RightBlock), row, r_anchor);
    delete RightBlock;

    // The blocks corresponding to the x_b part. 
    for i in [1..#LeftBlocks] do
      InsertBlock(~M, KroneckerProduct(IdentityMatrix(K, d_b), LeftBlocks[i]), 
        row, col);
      row +:= d_b*Nrows(LeftBlocks[i]);
    end for;
    delete LeftBlocks;
    
    col +:= d_b^2;
  end while;

  // Check repeats.
  if #repeats ne 0 then
    vprint TensorSpace, 1 : "Adding in possible fusion data.";
    R := __FusionBlock(K, dims, repeats, A);
    M := VerticalJoin(R, M);
  end if;

  return Transpose(M);
end function;



__A_Derivations_mat := function(seq, dims, A, repeats, k)
  // Initial setup.
  d := &*(dims);
  K := Parent(seq[1]);
  v := #dims;
  s := &+[dims[v-x]^2 : x in A];
  k_Subs := Subsets(A, k);
  M := ZeroMatrix(K, #k_Subs*d, s);

  // Start the bad boy up.
  vprintf TensorSpace, 1 : "Construting a %o by %o matrix over %o.\n", Ncols(M), 
    Nrows(M), K;

  // Construct the appropriate matrix.
  // We work from right to left.
  row := 1;
  for B in k_Subs do
    col := s+1;
    depth := d;
    A_comp := {0..v-1} diff A;
    
    // Run through all a in A and only do things if a in B.
    for a in Sort([x : x in A]) do
      d_a := dims[v-a];
      col -:= d_a^2;
      C := {c : c in A_comp | c lt a};
      A_comp diff:= C;
      depth div:= d_a * &*([dims[v-c] : c in C] cat [1]);
      B_row := row;

      if a in B then
        // A chopped up foliation.
        Mats := __Coordinate_Spread(seq, dims, a, depth);

        // Add the matrices to our big matrix.
        I := IdentityMatrix(K, d_a);
        r := d_a * Nrows(Mats[1]);
        for X in Mats do
          InsertBlock(~M, KroneckerProduct(I, X), B_row, col);
          B_row +:= r;
        end for;
      end if;

    end for;

    // Move down a stripe.
    row +:= d;

  end for;

  // Get the repeats block.
  vprint TensorSpace, 1 : "Adding in possible fusion data.";
  M := VerticalJoin(__FusionBlock(K, dims, repeats, A), M);
  M := Transpose(M); // fix this 

  // Solve the linear system.
  vprintf TensorSpace, 1 : "Created %o by %o relation matrix.\n", 
    Nrows(M), Ncols(M);
  return M;
end function;

// Given a tensor t, a set of coords A, a boolean F, a seq of 
// tuples B, and a string obj return space approximiating 
// the algebra derived from the tensor. 
__ApproximateAlgebra := function(t, A, F, B);
  coords := Reverse(Sort([a : a in A]));

  // if we should reduce by fuse, do it.
  if F then
    B, A_rep := __ReduceByFuse(B, t`Cat`Repeats, coords);
  else
    A_rep := A;

    // if this is a nuke, then transpose might be required.
    if (#A eq 2) and (0 notin A) then
      for i in [1..#B] do
        B[i][2] := Transpose(B[i][2]);
      end for;
    end if;

  end if;

  // put it all together and leave a trail of breadcrumbs. 
  basis := [DiagonalJoin(T) : T in B];
  MA := KMatrixSpace(BaseRing(t), Nrows(basis[1]), Nrows(basis[1]));
  Operators := sub< MA | basis >;
  //Operators := __GetSmallerRandomGenerators(Operators);
  //DerivedFrom(~Operators, t, A, A_rep : Fused := F);

  return Operators, B;
end function;

intrinsic DerivationAlgebraSVD( t::TenSpcElt : DownSize := false ) -> .
{Returns the (A, k)-derivation algebra of a real tensor t using SVD method.}
    return DerivationAlgebraSVD(t,{0..Valence(t)-1}, Valence(t));
end intrinsic;

intrinsic DerivationAlgebraSVD( t::TenSpcElt, A::{RngIntElt} : DownSize := false ) -> .
{Returns the A-derivation algebra of the tensor t.}
  return DerivationAlgebraSVD(t, A, #A : DownSize := DownSize );
end intrinsic;


intrinsic DerivationAlgebraSVD( t::TenSpcElt, A::{RngIntElt}, k::RngIntElt : DownSize := false) -> .
{Returns the (A, k)-derivation algebra of a real tensor t using SVD method.}
  // Make sure A makes sense.
  require Type(BaseRing(t)) eq FldRe : "Must be a real field for SVD.";

  require A subset {0..Valence(t)-1} : "Unknown coordinates.";
  require #A gt 0 : "Set must contain at least two coordinates.";
  if t`Cat`Contra then
    require 0 notin A : "Integers must be positive for cotensors.";
  end if;
  require k ge 1 : "Integer must be at least 2.";
  require k le #A : "Integer cannot be larger than set size.";

  // Out-source the k=2 case
  if k eq 2 then
    _ := CentroidSVD(t, A);
  end if;

  // Make sure we can obtain the structure constants. 
  try
    _ := Eltseq(t);
  catch err
    error "Cannot compute structure constants.";
  end try;

  // Check if the derivations have been computed before.
  ind := Index(t`Derivations[1], <A, k>);
  fuse := (k gt 2) select true else false;
  if Type(t`Derivations[2][ind]) ne RngIntElt then
    D := __ApproximateAlgebra(t, A, fuse, t`Derivations[2][ind]);
    return D;
  end if; 

  // Get the derivations.
  mat := __A_Derivations_mat(
            Eltseq(t), 
            [Dimension(X) : X in Frame(t)],
            A,
            t`Cat`Repeats, 
            k);
  // Computing Singular values


  vprintf TensorSpace, 1 : "Resizing %o by %o relation matrix.\n", 
    Nrows(mat), Ncols(mat);

  // Downsize.
  if DownSize then
    max := Minimum(Ncols(mat),Round(1.1*Nrows(mat)));
    js := [1..Ncols(mat)];  
    for i in [1..(Ncols(mat)-max)] do
        Remove(~js, Random([1..#js]) );
    end for;
      vprintf TensorSpace, 1 : "Using lables %o.\n", js;
    mat := Matrix(BaseRing(mat),Nrows(mat),#js, [mat[u[1],u[2]] : u in CartesianProduct([1..Nrows(mat)],js) ] );
  end if;

  vprintf TensorSpace, 1 : "Computing singular values of %o by %o relation matrix.\n", 
    Nrows(mat), Ncols(mat);

  thyme:=Cputime();
  S, U, V := SingularValueDecomposition(mat);
  Cputime(thyme);
  vprint TensorSpace, 1 : "Solve took time ", thyme;
  // Detect the singular values clustered around 0.
  sings := [S[i][i] : i in [1..Minimum(Nrows(S),Ncols(S))]];
  vprintf TensorSpace, 1 : "Singuler values %o\n", sings;
  // Scan last to first looking at the slopes of the normalized 
  start := __scan_SVD(sings);

  // Gather the singular vectors incident on these.
  gens := [ U[i] : i in [start..Nrows(U)]];

  // Construct the algebra and reduce to minimal representation.
  //D, basis := __ApproximateAlgebra(t, A, true, gens);

  // // Sanity check
  // if __SANITY_CHECK then
  //   printf "Sanity check (DerivationAlgebra)\n";
  //   assert __OperatorSanityCheck(D, k);
  // end if;

  // // Save it
  // t`Derivations[2][ind] := basis;
  return gens;//D;
end intrinsic;

intrinsic Centroid( t::TenSpcElt ) -> .
{Returns the centroid of a real or complex tensor t by SVD methods.}
  return Centroid(t, {0..Valence(t)-1});
end intrinsic;


intrinsic CentroidSVD( t::TenSpcElt, A::{RngIntElt} ) -> .
{Returns the A-centroid of a real or complex tensor t by SVD methods.}
  // Check that A makes sense.
  require Type(BaseRing(t)) eq FldRe : "Must be a real field for SVD.";
  require A subset {0..Valence(t)-1} : "Unknown tensor coordinates.";
  require #A ge 2 : "Must be at least two coordinates.";
  if t`Cat`Contra then
    require 0 notin A : "Integers must be positive for cotensors.";
  end if;
  require forall{X : X in Frame(t) | Dimension(X) gt 0} : 
      "Modules in frame must be positive dimensional.";
  
  // // |A| = 2 case.
  // if #A eq 2 then
  //   return NucleusSVD(t, Maximum(A), Minimum(A));
  // end if;

  // // Check if the centroid has been computed before.
  // ind := Index(t`Derivations[1], <A, 2>);
  // // If it has been, return it as an algebra. 
  // if Type(t`Derivations[2][ind]) ne RngIntElt then
  //   C := __MakeAlgebra(t, A, true, MatrixAlgebra, t`Derivations[2][ind]);
  //   return C;
  // end if;
   
  // Now it hasn't been computed before, and we need to compute something.
  // Make sure we can obtain the structure constants. 
  try
    _ := Eltseq(t);
  catch err
    error "Cannot compute structure constants.";
  end try;

  mat := __A_Centroid_mat(Eltseq(t), [Dimension(X) : X in Frame(t)], A : 
    repeats := t`Cat`Repeats);
  S, U, V := SingularValueDecomposition(mat);
  // Detect the singular values clustered around 0.
  sings := [S[i][i] : i in [1..Minimum(Nrows(S),Ncols(S))]];
  vprintf TensorSpace, 1 : "Singuler values\n", [Round(s*100)/100 : s in sings];
  // Scan last to first looking at the slopes of the normalized 
  start := __scan_SVD(sings);

  // Gather the singular vectors incident on these.
  gens := [ U[i] : i in [start..Nrows(U)]];


  // Construct algebra and reduce to minimal representation
  //C := __ApproximateAlgebra(t, A, true, gens);

  // // Sanity check
  // if __SANITY_CHECK then
  //   printf "Sanity check (Centroid)\n"; 
  //   assert __OperatorSanityCheck(C, 2);
  // end if;

  // // Checkpoint!
  // t`Derivations[2][ind] := basis;
  return gens;//C;
end intrinsic;
