__add_noise := function (a, epsilon)
return a + epsilon * Random ([-1000..1000]) / 1000;
end function;

AddNoise := function (t, epsilon) 
  l := Eltseq (t);
return Parent (t)![ __add_noise (l[i] , epsilon) : i in [1..#l] ];
end function;

Cubic := function( K, alpha )
  E := Matrix(K,3,3, [1,0,0, 0,0,alpha, 0,alpha,0 ] );
  F := Matrix(K,3,3, [0,1,0, 1,0,0, 0,0,alpha] );
  G := Matrix(K,3,3, [0,0,1, 0,1,0, 1,0,0] );
  return Tensor( [E,F,G], 2,1);
end function;

GHZ := function()
  TS := KTensorSpace(RealField(5),[2,2,2,2]);
  return TS.1+TS.16;
end function;

ext3 := function()
  K := RealField(5);
  E := Matrix(K,3,3, [0,1,0, -1,0,0, 0,0,0 ] );
  F := Matrix(K,3,3, [0,0,1, 0,0,0, -1,0,0] );
  G := Matrix(K,3,3, [0,0,0, 0,0,1, 0,-1,0] );
  return Tensor( [E,F,G], 2,1);

end function;

adsl2 := function()
  K := RealField(5);
  E := Matrix(K,3,3, [0,2,0, 0,0,1, 0,0,0 ] );
  F := Matrix(K,3,3, [2,0,0, 0,0,0, 0,0,-2] );
  G := Matrix(K,3,3, [0,0,0, -1,0,0, 0,-2,0] );
  return Tensor( [E,F,G], 2,1);
end function;

test := function( d )
  // i+j=k
  TS := KTensorSpace( RealField(5), [d,d,d]);
  T := TS!0;
  for i in [1..d] do
    for j in [1..d] do
      for k in [1..d] do
        if (i+j+k) eq (2*d-1) then 
          Assign(~T, [i,j,k], Random([1..5]));
        end if;
      end for;
    end for;
  end for;
  return T;
end function;


test2 := function( d )
  // i+j=k
  TS := KTensorSpace( RealField(5), [d,d,d]);
  T := TS!0;
  for i in [1..d] do
    for j in [1..d] do
      for k in [1..d] do
        if (i*i+j*j+k*k) eq (2*d-1) then 
          Assign(~T, [i,j,k], Random([1..5]));
        end if;
      end for;
    end for;
  end for;
  return T;
end function;